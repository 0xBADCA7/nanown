#!/usr/bin/env python3

import sys
import os
import time
import random
import tempfile
import argparse
import socket
import json

import numpy
import matplotlib.mlab as mlab
import matplotlib.pyplot as plt


VERSION = "{DEVELOPMENT}"
if VERSION == "{DEVELOPMENT}":
    script_dir = '.'
    try:
        script_dir = os.path.dirname(os.path.realpath(__file__))
    except:
        try:
            script_dir = os.path.dirname(os.path.abspath(sys.argv[0]))
        except:
            pass
    sys.path.append("%s/../lib" % script_dir)

from nanownlib import *
from nanownlib.stats import *
import nanownlib.storage


parser = argparse.ArgumentParser(
    description="")
parser.add_argument('db_file', default=None,
                    help='')
options = parser.parse_args()
db = nanownlib.storage.db(options.db_file)


def differences(db, unusual_case, rtt_type='packet'):
    ret_val = [s['unusual_'+rtt_type]-s['other_'+rtt_type] for s in db.subseries('train', unusual_case)]
    ret_val += [s['unusual_'+rtt_type]-s['other_'+rtt_type] for s in db.subseries('test', unusual_case)]
    return ret_val

def null_differences(db, unusual_case, rtt_type='packet'):
    ret_val = [s['unusual_'+rtt_type]-s['other_'+rtt_type] for s in db.subseries('train_null', unusual_case)]
    return ret_val


def timeSeries(db, probe_type, unusual_case):
    cursor = db.conn.cursor()
    query="""
      SELECT time_of_day,packet_rtt AS uc,(SELECT avg(packet_rtt) FROM probes,analysis
                                           WHERE analysis.probe_id=probes.id AND probes.test_case!=:unusual_case AND probes.type=:probe_type AND sample=u.sample) AS oc
      FROM (SELECT time_of_day,probes.sample,packet_rtt FROM probes,analysis 
                                           WHERE analysis.probe_id=probes.id AND probes.test_case =:unusual_case AND probes.type=:probe_type) u
    """
    
    params = {"probe_type":probe_type,"unusual_case":unusual_case}
    cursor.execute(query, params)
    for row in cursor:
        yield {'time_of_day':row['time_of_day'],unusual_case:row['uc'],'other_cases':row['oc']}
#samples,derived,null_derived = parse_data(input1)

#trust = trustValues(derived, sum)
#weights = linearWeights(derived, trust, 0.25)
#print('(test): %f' % weightedMean(derived,weights))

diffs = list(differences(db, 'long'))
reported_diffs = list(differences(db, 'long', 'reported'))
#shorts = [s['packet_rtt'] for s in samples.values() if s['test_case']=='short']
#longs = [s['packet_rtt'] for s in samples.values() if s['test_case']=='long']

short_overtime = [(sample['time_of_day'],sample['short']) for sample in timeSeries(db,'train','short')]
long_overtime = [(sample['time_of_day'],sample['long']) for sample in timeSeries(db,'train','long')]
diff_overtime = [(sample['time_of_day'],sample['long']-sample['other_cases']) for sample in timeSeries(db,'train','long')]
short_overtime.sort()
long_overtime.sort()
diff_overtime.sort()

print('packet_rtt diff mean: %f' % statistics.mean(diffs))
print('packet_rtt diff median: %f' % statistics.median(diffs))
print('packet_rtt diff midhinge: %f' % midsummary(diffs))
print('packet_rtt diff trimean: %f' % trimean(diffs))
print('packet_rtt diff quadsummary: %f' % quadsummary(diffs))
print('packet_rtt diff ubersummary: %f' % ubersummary(diffs))
print('packet_rtt diff septasummary: %f' % septasummary(diffs))
print('packet_rtt diff MAD: %f' % mad(diffs))
try:
    print('reported diff trimean: %f' % trimean(reported_diffs))
    print('reported diff quadsummary: %f' % quadsummary(reported_diffs))
    print('reported diff ubersummary: %f' % ubersummary(reported_diffs))
    print('reported diff septasummary: %f' % septasummary(reported_diffs))
    print('reported diff MAD: %f' % mad(reported_diffs))

    #import cProfile
    #start = time.time()
    #kresults = kfilter({},diffs)
    #print('packet_rtt diff kfilter: ', numpy.mean(kresults['est']), kresults['var'])
    #print('packet_rtt diff kfilter: ', kresults['est'][-1], kresults['var'][-1])
    #kresults = kfilter({},reported_diffs)
    #print('reported diff kfilter: ', numpy.mean(kresults['est']), kresults['var'][-1])
    #print('reported diff kfilter: ', kresults['est'][-1], kresults['var'][-1])
    #print("kfilter time: %f" % (time.time()-start))
except:
    pass

#print('tsval diff mean: %f' % numpy.mean(differences(db, 'long', 'tsval')))
#print('tsval null diff mean: %f' % numpy.mean(null_differences(db, 'long', 'tsval')))
#print('tsval diff weighted mean: %f' % tsvalwmean(db.subseries('train','long')+db.subseries('test','long')))
#print('tsval null diff weighted mean: %f' % tsvalwmean(db.subseries('train_null','long')))




def testKalman4D(params=None):
    from pykalman import KalmanFilter
    train = db.subseries('train','long', offset=0)
    test = db.subseries('test','long', offset=0)
    null = db.subseries('train_null','long', offset=0)
    measurements = numpy.asarray([(s['unusual_packet'],s['other_packet'],s['unusual_tsval'],s['other_tsval']) for s in (train+test)])
    null_measurements = numpy.asarray([(s['unusual_packet'],s['other_packet'],s['unusual_tsval'],s['other_tsval']) for s in null])
    
    if params == None:
        kf = KalmanFilter(n_dim_obs=4, n_dim_state=4,
                          initial_state_mean=[quadsummary([s['unusual_packet'] for s in train]),
                                              quadsummary([s['other_packet'] for s in train]),
                                              numpy.mean([s['unusual_tsval'] for s in train]),
                                              numpy.mean([s['other_tsval'] for s in train])])
        kf = KalmanFilter(n_dim_obs=4, n_dim_state=4)
        
        start=time.time()
        kf = kf.em(measurements[0:len(train)]+null_measurements[0:50000], n_iter=10,
                   em_vars=('transition_matrices',
                            'observation_matrices',
                            'transition_offsets',
                            'observation_offsets',
                            'transition_covariance',
                            'observation_covariance',
                            'initial_state_mean',
                            'initial_state_covariance'))
        params = {'transition_matrices': kf.transition_matrices.tolist(),
                  'observation_matrices': kf.observation_matrices.tolist(),
                  'transition_offsets': kf.transition_offsets.tolist(),
                  'observation_offsets': kf.observation_offsets.tolist(),
                  'transition_covariance': kf.transition_covariance.tolist(),
                  'observation_covariance': kf.observation_covariance.tolist(),
                  'initial_state_mean': kf.initial_state_mean.tolist(),
                  'initial_state_covariance': kf.initial_state_covariance.tolist()}
        print("Learned Params:\n")
        import pprint
        pprint.pprint(params)
        print("pykalman em time: %f" % (time.time()-start))
        
    #kf = KalmanFilter(n_dim_obs=2, n_dim_state=2, **params)

    num_obs=5000
    for offset in range(50000,100000+num_obs,num_obs):
        start=time.time()
        m = measurements[offset:offset+num_obs]
        #params['initial_state_mean']=[quadsummary([s[0] for s in m]),
        #                              quadsummary([s[1] for s in m]),
        #                              numpy.mean([s[2] for s in m]),
        #                              numpy.mean([s[3] for s in m])]
        kf = KalmanFilter(n_dim_obs=4, n_dim_state=4, **params)
        (smoothed_state_means, smoothed_state_covariances) = kf.smooth(m)
        #print("pykalman smooth time: %f" % (time.time()-start))
        up = numpy.mean([m[0] for m in smoothed_state_means])
        op = numpy.mean([m[1] for m in smoothed_state_means])
        #print("packet_rtt pykalman final:", smoothed_state_means[-1][0]-smoothed_state_means[-1][1])
        print("packet_rtt pykalman mean:", up-op)
        print("packet_rtt mean:", numpy.mean([s[0]-s[1] for s in m]))
        #up = numpy.mean([m[2] for m in smoothed_state_means])
        #op = numpy.mean([m[3] for m in smoothed_state_means])
        #print("tsval_rtt pykalman final:", smoothed_state_means[-1][2]-smoothed_state_means[-1][3])
        #print("tsval_rtt pykalman mean:", up-op)
        #print("tsval_rtt mean:", numpy.mean([s[2]-s[3] for s in m]))

    for offset in range(0,len(null_measurements)+num_obs,num_obs):
        start=time.time()
        m = null_measurements[offset:offset+num_obs]
        #params['initial_state_mean']=[quadsummary([s[0] for s in m]),
        #                              quadsummary([s[1] for s in m]),
        #                              numpy.mean([s[2] for s in m]),
        #                              numpy.mean([s[3] for s in m])]
        kf = KalmanFilter(n_dim_obs=4, n_dim_state=4, **params)
        (smoothed_state_means, smoothed_state_covariances) = kf.smooth(m)
        up = numpy.mean([m[0] for m in smoothed_state_means])
        op = numpy.mean([m[1] for m in smoothed_state_means])
        #print("null packet_rtt pykalman final:", smoothed_state_means[-1][0]-smoothed_state_means[-1][1])
        print("null packet_rtt pykalman mean:", up-op)
        print("null packet_rtt mean:", numpy.mean([s[0]-s[1] for s in m]))
        #up = numpy.mean([m[2] for m in smoothed_state_means])
        #op = numpy.mean([m[3] for m in smoothed_state_means])
        #print("null tsval_rtt pykalman final:", smoothed_state_means[-1][2]-smoothed_state_means[-1][3])
        #print("null tsval_rtt pykalman mean:", up-op)
        #print("null tsval_rtt mean:", numpy.mean([s[2]-s[3] for s in m]))

        

echo_vm_5k={'initial_state_covariance': [[33599047.5,
                               -18251285.25,
                               3242535690.59375,
                               -8560730487.84375],
                              [-18251285.25,
                               9914252.3125,
                               -1761372688.59375,
                               4650260880.1875],
                              [3242535690.59375,
                               -1761372688.59375,
                               312926663745.03125,
                               -826168494791.7188],
                              [-8560730487.84375,
                               4650260880.1875,
                               -826168494791.7188,
                               2181195982530.4688]],
 'initial_state_mean': [12939012.5625,
                        12934563.71875,
                        13134751.608,
                        13138990.9985],
 'observation_covariance': [[11960180434.411114,
                             4760272534.795976,
                             8797551081.431936,
                             6908794128.927051],
                            [4760272534.795962,
                             12383598172.428213,
                             5470747537.2599745,
                             11252625555.297853],
                            [8797551081.431955,
                             5470747537.2601185,
                             1466222848395.7058,
                             72565713883.12643],
                            [6908794128.927095,
                             11252625555.297981,
                             72565713883.12654,
                             1519760903943.507]],
 'observation_matrices': [[1.4255288693095167,
                           -0.4254638445329988,
                           0.0003406844036817347,
                           -0.0005475021956726778],
                          [-0.46467270827589857,
                           1.4654311778340343,
                           -0.0003321330280128265,
                           -0.0002853945703691352],
                          [-0.2644570970067974,
                           -0.33955835481495455,
                           1.7494161615202275,
                           -0.15394117603733548],
                          [-0.3419097544041847,
                           -0.23992883666045373,
                           -0.15587790880447727,
                           1.7292393175137022]],
 'observation_offsets': [165.2279084503762,
                         157.76807691937614,
                         168.4235495099334,
                         225.33433430227353],
 'transition_covariance': [[2515479496.145993,
                            -401423541.70620924,
                            1409951418.1627903,
                            255932902.74454522],
                           [-401423541.706214,
                            2744353887.676857,
                            1162316.2019491254,
                            1857251491.3987627],
                           [1409951418.1628358,
                            1162316.2020361447,
                            543279068599.8229,
                            -39399311190.5746],
                           [255932902.74459982,
                            1857251491.398838,
                            -39399311190.574585,
                            537826124257.5266]],
 'transition_matrices': [[0.52163952865412,
                          0.47872618354122665,
                          -0.0004322286766109684,
                          0.00017293351811531466],
                         [0.5167436693545113,
                          0.48319044922845933,
                          7.765428142114672e-05,
                          -0.00021518950285326355],
                         [0.2091705950622469,
                          0.41051399729482796,
                          0.19341113299389256,
                          0.19562916616052917],
                         [0.368592004009912,
                          0.22263632461118732,
                          0.20756792378812872,
                          0.20977025833570906]],
 'transition_offsets': [592.5708159274,
                        583.3804671015271,
                        414.4187239098291,
                        562.166786712371]}

echo_vm_5k={'initial_state_covariance': [[0.375, 0.0, 0.0, 0.0],
                              [0.0, 0.375, 0.0, 0.0],
                              [0.0, 0.0, 0.375, 0.0],
                              [0.0, 0.0, 0.0, 0.375]],
 'initial_state_mean': [15997944.198361743,
                        16029825.435899183,
                        17093077.26228404,
                        17524263.088803563],
 'observation_covariance': [[36572556646.179054,
                             21816054953.37006,
                             31144379008.310543,
                             19651005729.823025],
                            [21816054953.372543,
                             440428106325.20325,
                             41103447776.740585,
                             427146570672.51227],
                            [31144379008.31037,
                             41103447776.74027,
                             3280009435458.6953,
                             458734528073.65686],
                            [19651005729.82234,
                             427146570672.5109,
                             458734528073.6557,
                             3769493190697.773]],
 'observation_matrices': [[1.0248853427592337,
                           -0.031198859962501047,
                           0.001613706836380402,
                           0.004720209443291878],
                          [-0.8604422900368718,
                           1.8583369609057172,
                           -0.0022646214457040514,
                           0.004437933935378169],
                          [-0.5814771409524866,
                           0.22228184387142846,
                           1.6259599749174072,
                           -0.271594798325566],
                          [-0.5862601003257453,
                           0.2598285939005791,
                           -0.28286590143513024,
                           1.604087079832425]],
 'observation_offsets': [1979.4518332096984,
                         1889.3380163762793,
                         2132.9112026744906,
                         1750.7759421584785],
 'transition_covariance': [[6176492087.271547,
                            762254719.4171592,
                            4584288694.652873,
                            3044796192.4357214],
                           [762254719.4185101,
                            173302376079.4761,
                            5261303152.757347,
                            167562483383.9925],
                           [4584288694.651718,
                            5261303152.755746,
                            1056156956874.4131,
                            -115859156952.07962],
                           [3044796192.434162,
                            167562483383.9901,
                            -115859156952.08018,
                            1225788436266.3086]],
 'transition_matrices': [[0.9673912485796876,
                          0.03252962227543321,
                          0.0006756067792537124,
                          -0.0006566638567164773],
                         [0.9548761966068113,
                          0.03841774395880293,
                          0.00426067282319309,
                          0.002303362691861821],
                         [0.6215040230859188,
                          -0.2584476837756142,
                          0.3176491193420503,
                          0.3241682768126566],
                         [0.6634028281470279,
                          -0.33548335246018723,
                          0.3298144902195048,
                          0.3475836278392421]],
 'transition_offsets': [1751.3049487348183,
                        1764.989515773476,
                        1986.8405778425586,
                        2232.830254345267]}
#testKalman4D(echo_vm_5k)



def testKalman(params=None):
    from pykalman import AdditiveUnscentedKalmanFilter,KalmanFilter
    train = db.subseries('train','long', offset=0)
    test = db.subseries('test','long', offset=0)
    measurements = numpy.asarray([(s['unusual_packet'],s['other_packet']) for s in (train+test)])

    #kf = KalmanFilter(transition_matrices = [[1, 1], [0, 1]], observation_matrices = [[0.1, 0.5], [-0.3, 0.0]])
    kf = KalmanFilter(n_dim_obs=2, n_dim_state=2,
                      initial_state_mean=[quadsummary([s['unusual_packet'] for s in train]),
                                          quadsummary([s['other_packet'] for s in train])])
    #kf = AdditiveUnscentedKalmanFilter(n_dim_obs=2, n_dim_state=2)

    if params == None:
        start=time.time()
        kf = kf.em(measurements[0:len(train)], n_iter=10,
                   em_vars=('transition_matrices',
                            'observation_matrices',
                            'transition_offsets',
                            'observation_offsets',
                            'transition_covariance',
                            'observation_covariance',
                            'initial_state_covariance'))
        params = {'transition_matrices': kf.transition_matrices.tolist(),
                  'observation_matrices': kf.observation_matrices.tolist(),
                  'transition_offsets': kf.transition_offsets.tolist(),
                  'observation_offsets': kf.observation_offsets.tolist(),
                  'transition_covariance': kf.transition_covariance.tolist(),
                  'observation_covariance': kf.observation_covariance.tolist(),
                  'initial_state_mean': kf.initial_state_mean.tolist(),
                  'initial_state_covariance': kf.initial_state_covariance.tolist()}
        print("Learned Params:\n")
        import pprint
        pprint.pprint(params)
        print("pykalman em time: %f" % (time.time()-start))
        
    #kf = KalmanFilter(n_dim_obs=2, n_dim_state=2, **params)

    num_obs=10000
    for offset in range(50000,100000+num_obs,num_obs):
        start=time.time()
        kf = KalmanFilter(n_dim_obs=2, n_dim_state=2, **params)
        m = measurements[offset:offset+num_obs]
        (smoothed_state_means, smoothed_state_covariances) = kf.smooth(m)
        print("pykalman smooth time: %f" % (time.time()-start))
        up = numpy.mean([m[0] for m in smoothed_state_means])
        op = numpy.mean([m[1] for m in smoothed_state_means])
        print("packet_rtt pykalman final:", smoothed_state_means[-1][0]-smoothed_state_means[-1][1])
        print("packet_rtt pykalman mean:", up-op)
        print("packet_rtt mean:", numpy.mean([s[0]-s[1] for s in m]))


five_iter = {'observation_offsets': [-54.53185823, -55.25219184],
            'observation_covariance': [[  1.15059170e+10,   4.36743765e+09],
                                       [  4.36743765e+09,   1.19410313e+10]],
            'initial_state_mean': [ 12939012.5625 ,  12934563.71875],
            'transition_covariance': [[  2.98594543e+09,   6.86355073e+07],
                                      [  6.86355073e+07,   3.21368699e+09]],
            'initial_state_covariance': [[  2.36836696e+09,   1.63195635e+09],
                                         [  1.63195635e+09,   1.12452233e+09]],
            'transition_offsets': [ 343.69740217,  338.5042467 ],
            'observation_matrices': [[ 1.42539895, -0.4255261 ],
                                     [-0.46280375,  1.46295189]],
            'transition_matrices': [[ 0.56151623,  0.4385931 ],
                                    [ 0.47309189,  0.52673508]]}
ten_iter = {'initial_state_covariance': [[229936928.28125, 41172601.0],
                                         [41172601.0, 7372383.46875]],
            'initial_state_mean': [12939012.5625, 12934563.71875],
            'observation_covariance': [[11958914107.88334, 4761048283.066559],
                                       [4761048283.066557, 12388186543.42032]],
            'observation_matrices': [[1.4258395826727792, -0.42598392357467674],
                                     [-0.4647443890462455, 1.4648767294384015]],
            'observation_offsets': [165.409715349344, 157.96206130876212],
            'transition_covariance': [[2515594742.7187943, -401728959.41375697],
                                      [-401728959.41375697, 2743831805.402682]],
            'transition_matrices': [[0.521306461057975, 0.47879632652984583],
                                    [0.5167881285851763, 0.483006520280469]],
            'transition_offsets': [592.4419187566978, 583.2272403965366]}
#testKalman(ten_iter)


def getTCPTSPrecision():
    cursor = db.conn.cursor()
    query="""SELECT tcpts_mean FROM meta"""
    cursor.execute(query)
    row = cursor.fetchone()
    if row:
        return row[0]
    return None


def tsFilteredHistogram():
    tcpts_precision = getTCPTSPrecision()
    
    num_bins = 500
    all = db.subseries('train','long')+db.subseries('test','long')
    diffs     = [s['unusual_packet']-s['other_packet'] for s in all]
    ts0_diffs = [s['unusual_packet']-s['other_packet'] for s in all if s['unusual_tsval']-s['other_tsval'] == 0]
    ts1_diffs = [s['unusual_packet']-s['other_packet'] for s in all if abs(s['unusual_tsval']-s['other_tsval']) > 0]
    ts2_diffs = [s['unusual_packet']-s['other_packet'] for s in all if abs(round((s['unusual_tsval']-s['other_tsval'])/tcpts_precision)) <= 1.0]

    ts_mode = statistics.mode([s['unusual_tsval'] for s in all]+[s['other_tsval'] for s in all])
    ts_diff_mode = statistics.mode([s['unusual_tsval']-s['other_tsval'] for s in all])
    ts_common_mode = [s['unusual_packet']-s['other_packet'] for s in all if s['unusual_tsval']<=ts_mode and s['other_tsval']<=ts_mode]
    ts_common_diff_mode = [s['unusual_packet']-s['other_packet'] for s in all if s['unusual_tsval']-s['other_tsval']==ts_diff_mode]

    print('packet_rtt diff quadsummary: %f' % quadsummary(diffs))
    print('packet_rtt tsval diff=0 quadsummary: %f' % quadsummary(ts0_diffs))
    print('packet_rtt tsval diff>0 quadsummary: %f' % quadsummary(ts1_diffs))
    print('packet_rtt tsval diff<=1 quadsummary: %f' % quadsummary(ts2_diffs))
    print('packet_rtt tsval mode quadsummary: %f' % quadsummary(ts_common_mode))
    print(len(diffs), len(ts0_diffs)+len(ts1_diffs))
    diffs.sort()
    cut_off_low = diffs[int(len(diffs)*0.005)]
    cut_off_high = diffs[int(len(diffs)*0.995)]

    plt.clf()
    # the histogram of the data
    n, bins, patches = plt.hist(diffs, num_bins, normed=0, color='black', histtype='step', alpha=0.8,
                                range=(cut_off_low,cut_off_high), label='all')
    n, bins, patches = plt.hist(ts0_diffs, num_bins, normed=0, color='blue', histtype='step', alpha=0.8,
                                range=(cut_off_low,cut_off_high), label='tsval diff=0')
    n, bins, patches = plt.hist(ts1_diffs, num_bins, normed=0, color='red', histtype='step', alpha=0.8,
                                range=(cut_off_low,cut_off_high), label='tsval diff>0')
    n, bins, patches = plt.hist(ts2_diffs, num_bins, normed=0, color='orange', histtype='step', alpha=0.8,
                                range=(cut_off_low,cut_off_high), label='tsval diff<=1')
    #n, bins, patches = plt.hist(ts_common_mode, num_bins, normed=0, color='green', histtype='step', alpha=0.8,
    #                            range=(cut_off_low,cut_off_high), label='tsval common mode')
    n, bins, patches = plt.hist(ts_common_diff_mode, num_bins, normed=0, color='green', histtype='step', alpha=0.8,
                                range=(cut_off_low,cut_off_high), label='tsval common diff mode')
    plt.xlabel('RTT Difference')
    plt.ylabel('Probability')
    plt.title(r'Histogram - distribution of differences by tsval')

    # Tweak spacing to prevent clipping of ylabel
    plt.subplots_adjust(left=0.15)
    plt.legend()
    plt.show()
    #plt.savefig('paper/graphs/dists-vs-dist-of-diffs2.svg')

#tsFilteredHistogram()





#all_data = longs+shorts
#all_data.sort()
#cut_off_low = all_data[0]
#cut_off_high = all_data[int(len(all_data)*0.997)]


def plotSingleProbe(probe_id=None):
    if probe_id == None:
        cursor = db.conn.cursor()
        query="""SELECT probe_id FROM analysis WHERE suspect='' ORDER BY probe_id DESC limit 1 OFFSET 10"""
        cursor.execute(query)
        probe_id = cursor.fetchone()[0]
    
    cursor = db.conn.cursor()
    query="""SELECT observed,payload_len FROM packets WHERE probe_id=? AND sent=1"""
    cursor.execute(query, (probe_id,))
    pkts = cursor.fetchall()
    sent_payload = [row[0] for row in pkts if row[1] != 0]
    sent_other = [row[0] for row in pkts if row[1] == 0]
    
    query="""SELECT observed,payload_len FROM packets WHERE probe_id=? AND sent=0"""
    cursor.execute(query, (probe_id,))
    pkts = cursor.fetchall()
    rcvd_payload = [row[0] for row in pkts if row[1] != 0]
    rcvd_other = [row[0] for row in pkts if row[1] == 0]
    
    #query="""SELECT reported,time_of_day FROM probes WHERE id=?"""
    #cursor.execute(query, (probe_id,))
    #reported,tod = cursor.fetchone()
    #userspace_times = [sent_times[0]-reported/3.0, sent_times[0]+reported]

    print("single probe counts:",len(sent_payload),len(sent_other),len(rcvd_payload),len(rcvd_other))
    plt.clf()
    plt.title("Single HTTP Request - Packet Times")
    sp = plt.eventplot(sent_payload, colors=('red',), lineoffsets=8, linewidths=2, alpha=0.6,label='sent')
    so = plt.eventplot(sent_other, colors=('red',), lineoffsets=6, linewidths=2, alpha=0.6,label='sent')
    rp = plt.eventplot(rcvd_payload, colors=('blue',), lineoffsets=4, linewidths=2, alpha=0.6,label='received')
    ro = plt.eventplot(rcvd_other, colors=('blue',), lineoffsets=2, linewidths=2, alpha=0.6,label='received')
    #plt.legend((s,r), ('sent','received'))
    #plt.savefig('../img/http-packet-times.svg')
    plt.show()

#plotSingleProbe()


def graphTestResults():
    plt.clf()
    plt.title("Test Results")
    plt.xlabel('sample size')
    plt.ylabel('error rate')
    legend = []
    colors = ['red','blue','green','purple','orange','black','brown']
    color_id = 0

    cursor = db.conn.cursor()
    query = """
      SELECT classifier FROM classifier_results GROUP BY classifier ORDER BY classifier;
    """
    cursor.execute(query)
    classifiers = []
    for c in cursor:
        classifiers.append(c[0])

    max_obs = 0
    for classifier in classifiers:
        query="""
        SELECT params FROM classifier_results 
        WHERE trial_type='test'
         AND classifier=:classifier
         AND (false_positives+false_negatives)/2.0 < 5.0 
        ORDER BY num_observations,(false_positives+false_negatives) 
        LIMIT 1
        """
        cursor.execute(query, {'classifier':classifier})
        row = cursor.fetchone()
        if row == None:
            query="""
            SELECT params FROM classifier_results 
            WHERE trial_type='test' and classifier=:classifier
            ORDER BY (false_positives+false_negatives),num_observations
            LIMIT 1
            """
            cursor.execute(query, {'classifier':classifier})
            row = cursor.fetchone()
            if row == None:
                sys.stderr.write("WARN: couldn't find test results for classifier '%s'.\n" % classifier)
                continue

        best_params = row[0]
        query="""
        SELECT num_observations,(false_positives+false_negatives)/2.0 FROM classifier_results 
        WHERE trial_type='test'
         AND classifier=:classifier
         AND params=:params 
        ORDER BY num_observations
        """
        cursor.execute(query, {'classifier':classifier,'params':best_params})

        num_obs = []
        performance = []
        for row in cursor:
            max_obs = max(max_obs, row[0])
            num_obs.append(row[0])
            performance.append(row[1])
        #print(num_obs,performance)
        path = plt.scatter(num_obs, performance, color=colors[color_id], s=4, alpha=0.8, linewidths=3.0)
        plt.plot(num_obs, performance, color=colors[color_id], alpha=0.8)
        legend.append((classifier,path))
        color_id = (color_id+1) % len(colors)

    plt.legend([l[1] for l in legend], [l[0] for l in legend], scatterpoints=1, fontsize='xx-small')
    plt.plot([0, max_obs], [5.0, 5.0], "k--")
    plt.show()
        
graphTestResults()

sys.exit(0)

plt.clf()
plt.title("Packet RTT over time")
plt.xlabel('Time of Day')
plt.ylabel('RTT')
s = plt.scatter([t for t,rtt in short_overtime], [rtt for t,rtt in short_overtime], s=1, color='red', alpha=0.6)
l = plt.scatter([t for t,rtt in long_overtime], [rtt for t,rtt in long_overtime], s=1, color='blue', alpha=0.6)
d = plt.scatter([t for t,rtt in diff_overtime], [rtt for t,rtt in diff_overtime], s=1, color='purple', alpha=0.6)
plt.legend((s,l,d), ('short','long','difference'), scatterpoints=1)
#plt.savefig('paper/figures/comcast-powerboost1.png')
plt.show()



plt.clf()
plt.title("Simple HTTP Request")
plt.xlabel('Time of Day')
plt.ylabel('')
s = plt.scatter(sent_times, [2]*len(sent_times), s=3, color='red', alpha=0.9)
r = plt.scatter(rcvd_times, [1]*len(rcvd_times), s=3, color='blue', alpha=0.9)
plt.legend((s,r), ('sent','received'), scatterpoints=1)
plt.show()

sys.exit(0)
short_overtime,long_overtime,diff_overtime = None,None,None


num_bins = 300
reported_diffs.sort()
cut_off_low = reported_diffs[int(len(diffs)*0.003)]
cut_off_high = reported_diffs[int(len(diffs)*0.997)]

plt.clf()
# the histogram of the data
n, bins, patches = plt.hist(reported_diffs, num_bins, normed=1, color='black', histtype='step', alpha=0.8,
                            range=(cut_off_low,cut_off_high))
plt.xlabel('RTT Difference')
plt.ylabel('Probability')
plt.title(r'Histogram - distribution of differences')

# Tweak spacing to prevent clipping of ylabel
plt.subplots_adjust(left=0.15)
#plt.legend()
plt.show()
#plt.savefig('paper/graphs/dists-vs-dist-of-diffs2.svg')




num_bins = 300
diffs.sort()
cut_off_low = diffs[int(len(diffs)*0.003)]
cut_off_high = diffs[int(len(diffs)*0.997)]

plt.clf()
# the histogram of the data
n, bins, patches = plt.hist(diffs, num_bins, normed=1, color='purple', histtype='step', alpha=0.8,
                            range=(cut_off_low,cut_off_high))
plt.xlabel('RTT Difference')
plt.ylabel('Probability')
plt.title(r'Histogram - distribution of differences')

# Tweak spacing to prevent clipping of ylabel
plt.subplots_adjust(left=0.15)
#plt.legend()
plt.show()
#plt.savefig('paper/graphs/dists-vs-dist-of-diffs2.svg')

sys.exit(0)



num_bins = 150
# the histogram of the data
n, bins, patches = plt.hist((shorts,longs), num_bins, normed=1, label=['short', 'long'], color=['red','blue'], histtype='step', alpha=0.8,
                            range=(cut_off_low,cut_off_high))
#n, bins, patches = plt.hist(shorts2+longs2, num_bins, normed=1, facecolor='blue', histtype='step', alpha=0.3)
# add a 'best fit' line
#y = mlab.normpdf(bins, mu, sigma)
#plt.plot(bins, y, 'r--')
plt.xlabel('packet_rtt')
plt.ylabel('Probability')
plt.title(r'Histogram - RTT short and long')

# Tweak spacing to prevent clipping of ylabel
plt.subplots_adjust(left=0.15)
plt.legend()
#plt.show()
plt.savefig('paper/figures/comcast-powerboost2.svg')




num_trials = 200


subsample_sizes = (50,150,300,500,700,1000,2000,3000,5000,7000,10000,15000,20000)
estimator = functools.partial(boxTest, 0.07, 0.08)
performance = []
for subsample_size in subsample_sizes:
    estimates = bootstrap(derived, subsample_size, num_trials, estimator)
    performance.append(100.0*len([e for e in estimates if e == 1])/num_trials)

null_performance = []
for subsample_size in subsample_sizes:
    null_estimates = bootstrap(null_derived, subsample_size, num_trials, estimator)
    null_performance.append(100.0*len([e for e in null_estimates if e == 0])/num_trials)

plt.clf()
plt.title("boxTest bootstrap")
plt.xlabel('sample size')
plt.ylabel('performance')
plt.scatter(subsample_sizes, performance, s=2, color='red', alpha=0.6)
plt.scatter(subsample_sizes, null_performance, s=2, color='blue', alpha=0.6)
plt.show()



subsample_sizes = (50,150,300,400,500,700,1000,2000,3000,4000,5000,7000,10000)
estimator = diffMedian
performance = []
for subsample_size in subsample_sizes:
    estimates = bootstrap(derived, subsample_size, num_trials, estimator)
    performance.append(100.0*len([e for e in estimates if e > expected_mean*0.9 and e < expected_mean*1.1])/num_trials)

plt.clf()
plt.title("diff median bootstrap")
plt.xlabel('sample size')
plt.ylabel('performance')
plt.scatter(subsample_sizes, performance, s=1, color='red', alpha=0.6)
plt.show()




subsample_sizes = (50,150,300,400,500,700,1000,2000,3000,4000,5000,7000,10000)
weight_funcs = (linearWeights, prunedWeights)
for wf in weight_funcs:
    estimator = functools.partial(estimateMean, hypotenuse, wf, 0.40)
    performance = []
    for subsample_size in subsample_sizes:
        estimates = bootstrap(derived, subsample_size, num_trials, estimator)
        performance.append(100.0*len([e for e in estimates if e > expected_mean*0.9 and e < expected_mean*1.1])/num_trials)

    plt.clf()
    plt.title(repr(wf))
    plt.xlabel('sample size')
    plt.ylabel('performance')
    plt.scatter(subsample_sizes, performance, s=1, color='red', alpha=0.6)
    plt.show()



num_bins = 300
# the histogram of the data
n, bins, patches = plt.hist((tsshorts,tslongs), num_bins, normed=1, label=['short', 'long'], color=['red','blue'], histtype='step', alpha=0.8)
#n, bins, patches = plt.hist(shorts2+longs2, num_bins, normed=1, facecolor='blue', histtype='step', alpha=0.3)
# add a 'best fit' line
#y = mlab.normpdf(bins, mu, sigma)
#plt.plot(bins, y, 'r--')
plt.xlabel('packet_rtt')
plt.ylabel('Probability')
plt.title(r'Histogram - tsval_rtt short vs long')

# Tweak spacing to prevent clipping of ylabel
plt.subplots_adjust(left=0.15)
plt.legend()
plt.show()



    
####
#trust_methods = [min,max,sum,difference,product]
trust_methods = [sum,product,hypotenuse]
colors = ['red','blue','green','purple','orange','black']
weight_methods = [prunedWeights, linearWeights]
alphas = [i/100.0 for i in range(0,100,2)]




plt.clf()
plt.title(r'Trust Method Comparison - Linear')
plt.xlabel('Alpha')
plt.ylabel('Mean error')
paths = []
for tm in trust_methods:
    trust = trustValues(derived, tm)
    series = []
    for alpha in alphas:
        weights = linearWeights(derived, trust, alpha)
        series.append(weightedMean(derived, weights) - expected_mean)

    paths.append(plt.scatter(alphas, series, s=1, color=colors[len(paths)],alpha=0.6))

plt.legend(paths, [repr(tm) for tm in trust_methods], scatterpoints=1)
plt.show()



plt.clf()
plt.title(r'Trust Method Comparison - Pruned')
plt.xlabel('Alpha')
plt.ylabel('Mean error')
paths = []
for tm in trust_methods:
    trust = trustValues(derived, tm)
    series = []
    for alpha in alphas:
        weights = prunedWeights(derived, trust, alpha)
        series.append(weightedMean(derived, weights) - expected_mean)

    paths.append(plt.scatter(alphas, series, s=1, color=colors[len(paths)],alpha=0.6))

plt.legend(paths, [repr(tm) for tm in trust_methods], scatterpoints=1)
plt.show()


sys.exit(0)

plt.clf()
plt.title(r'Trust Method Comparison - Inverted')
plt.xlabel('Alpha')
plt.ylabel('Mean error')
paths = []
for tm in trust_methods:
    trust = trustValues(derived, tm)
    series = []
    for alpha in alphas:
        weights = invertedWeights(derived, trust, alpha)
        series.append(weightedMean(derived, weights) - expected_mean)

    paths.append(plt.scatter(alphas, series, s=1, color=colors[len(paths)],alpha=0.6))

plt.legend(paths, [repr(tm) for tm in trust_methods], scatterpoints=1)
plt.show()


plt.clf()
plt.title(r'Trust Method Comparison - Arctangent')
plt.xlabel('Alpha')
plt.ylabel('Mean error')
paths = []
for tm in trust_methods:
    trust = trustValues(derived, tm)
    series = []
    for alpha in alphas:
        weights = arctanWeights(derived, trust, alpha)
        series.append(weightedMean(derived, weights) - expected_mean)

    paths.append(plt.scatter(alphas, series, s=1, color=colors[len(paths)],alpha=0.6))

plt.legend(paths, [repr(tm) for tm in trust_methods], scatterpoints=1)
plt.show()
